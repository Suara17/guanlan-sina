# 开发计划与测试策略

## 第一章 开发计划与里程碑

### 1.1 项目阶段规划

#### 第一阶段：基础架构搭建（4周）

**Week 1-2: 技术选型与环境搭建**
- 确认前后端技术栈（适配FastAPI + Vue.js模板）
- 搭建开发、测试、生产环境
- 配置CI/CD流程
- 建立代码仓库与分支策略

**Week 3-4: 数据层建设**
- PostgreSQL表结构设计与创建
- InfluxDB Measurement配置
- Neo4j图谱模型设计
- Celery + Redis队列创建
- Redis缓存策略定义

**交付物**:
- 完整的开发环境
- 数据库Schema文档
- 基础架构部署文档

#### 第二阶段：观澜核心功能开发（6周）

**Week 5-6: 生产总览模块**
- 仪表盘API开发
- 前端Dashboard组件
- 实时数据WebSocket推送
- 多产线切换功能

**Week 7-8: 质量监控模块**
- 质量指标统计API
- 趋势图表组件
- 帕累托分析功能
- 缺陷图像墙

**Week 9-10: 追溯与报表**
- 工单追溯API
- 下钻交互实现
- Excel/PDF报表导出
- 数据权限过滤

**交付物**:
- 观澜系统MVP版本
- 用户操作手册
- API文档

#### 第三阶段：司南核心功能开发（8周）

**Week 11-12: 异常管理**
- 异常列表与详情API
- 实时告警推送
- 桌面通知集成

**Week 13-15: 知识图谱诊断**
- Neo4j图谱查询API
- G6知识图谱可视化
- 证据链展示
- 交互式节点探索

**Week 16-17: 方案推荐**
- 方案对比表组件
- 布局可视化组件
- 仿真结果嵌入
- ROI预演展示

**Week 18: 执行与复盘**
- 工单管理系统
- 执行跟踪功能
- 案例库归档
- 历史案例搜索

**交付物**:
- 司南系统完整版本
- 知识图谱配置指南
- 案例库使用手册

#### 第四阶段：集成测试与优化（4周）

**Week 19-20: 系统集成测试**
- 端到端功能测试
- 性能压力测试
- 安全渗透测试
- 跨浏览器兼容测试

**Week 21-22: 优化与修复**
- 性能优化（代码分割、懒加载）
- Bug修复
- UI/UX优化
- 文档完善

**交付物**:
- 测试报告
- 性能优化报告
- 完整系统文档

#### 第五阶段：试运行与上线（2周）

**Week 23: 试运行**
- 选择试点产线
- 用户培训
- 收集反馈
- 快速迭代

**Week 24: 正式上线**
- 全产线推广
- 监控与运维
- 持续支持

**交付物**:
- 上线检查清单
- 运维手册
- 培训材料

### 1.2 资源配置建议

| 角色 | 人数 | 职责 |
|------|------|------|
| 项目经理 | 1 | 整体项目协调与进度把控 |
| 前端开发工程师 | 3 | Vue.js组件开发、图表集成 |
| 后端开发工程师 | 3 | API开发、数据库设计 |
| 全栈工程师 | 2 | WebSocket、Celery集成 |
| UI/UX设计师 | 1 | 界面设计、交互原型 |
| 测试工程师 | 2 | 功能测试、自动化测试 |
| DevOps工程师 | 1 | 基础设施、CI/CD配置 |
| 产品经理 | 1 | 需求管理、用户沟通 |
| 技术文档工程师 | 1 | 文档编写与维护 |

### 1.3 关键风险与应对措施

| 风险类型 | 风险描述 | 影响等级 | 应对措施 |
|---------|---------|---------|---------|
| 技术风险 | 知识图谱可视化性能问题 | 高 | 提前进行POC验证，准备降级方案（简化图谱展示） |
| 技术风险 | WebSocket连接不稳定 | 中 | 实现断线重连机制，心跳检测，消息队列缓冲 |
| 集成风险 | 底层模块数据格式不统一 | 高 | 定义统一数据规范，建立数据适配层 |
| 性能风险 | 大数据量下页面卡顿 | 中 | 虚拟滚动、分页加载、数据聚合预计算 |
| 数据风险 | 数据口径不一致导致混乱 | 高 | 建立统一数据服务层，严格Code Review |
| 进度风险 | 前端组件开发进度延迟 | 中 | 并行开发，优先核心功能，准备组件库备选方案 |
| 人员风险 | 关键开发人员离职 | 中 | 代码规范化，文档齐全，知识分享会 |
| 需求风险 | 需求频繁变更 | 中 | 需求冻结机制，版本管理，敏捷迭代 |

---

## 第二章 测试策略

### 2.1 测试金字塔

```
         /\
        /  \  E2E测试（10%）- 关键业务流程端到端验证
       /----\
      /      \ 集成测试（30%）- API、数据库、消息队列集成
     /--------\
    /          \ 单元测试（60%）- 组件、函数、工具类
   /____________\
```

### 2.2 单元测试

#### 2.2.1 前端组件测试

```javascript
// KnowledgeGraph.test.ts (使用Vitest)
import { describe, it, expect, vi } from 'vitest';
import { mount } from '@vue/test-utils';
import KnowledgeGraph from './KnowledgeGraph.vue';

describe('KnowledgeGraph Component', () => {
  const mockNodes = [
    { id: '1', label: '划痕异常', type: 'problem' },
    { id: '2', label: '刀具磨损', type: 'cause', confidence: 0.85 }
  ];

  const mockEdges = [
    { source: '1', target: '2', type: 'causal' }
  ];

  it('should render graph container', () => {
    const wrapper = mount(KnowledgeGraph, {
      props: { nodes: mockNodes, edges: mockEdges, centerNodeId: '1' }
    });

    expect(wrapper.find('.knowledge-graph-container').exists()).toBe(true);
  });

  it('should emit node-click when node is clicked', () => {
    const wrapper = mount(KnowledgeGraph, {
      props: { nodes: mockNodes, edges: mockEdges, centerNodeId: '1' }
    });

    // 模拟节点点击（需要mock G6的事件）
    // ...具体测试逻辑
  });
});
```

#### 2.2.2 后端服务测试

```python
# tests/test_services.py (使用pytest)
import pytest
from sqlalchemy.ext.asyncio import AsyncSession
from app.services.production import get_production_overview
from app.db.models.production import ProductionLine

@pytest.mark.asyncio
async def test_get_production_overview(db_session: AsyncSession):
    # 添加测试数据
    line = ProductionLine(line_id="LINE-A", line_name="产线A", factory_id="FACTORY-1", status="active")
    db_session.add(line)
    await db_session.commit()

    result = await get_production_overview(db_session, "LINE-A", "24h")

    assert result.line_id == "LINE-A"

@pytest.mark.asyncio
async def test_get_production_overview_not_found(db_session: AsyncSession):
    with pytest.raises(ValueError, match="Production line not found"):
        await get_production_overview(db_session, "INVALID-LINE", "24h")
```

### 2.3 集成测试

#### 2.3.1 API集成测试

```python
# tests/test_api.py (使用pytest + httpx)
import pytest
from httpx import AsyncClient
from app.main import app

@pytest.mark.asyncio
async def test_production_overview():
    async with AsyncClient(app=app, base_url="http://test") as ac:
        # 假设mock认证
        response = await ac.get("/api/v1/production/overview?line_id=LINE-A&time_range=24h", headers={"Authorization": "Bearer test-token"})

        assert response.status_code == 200
        assert "line_id" in response.json()["data"]

@pytest.mark.asyncio
async def test_production_overview_unauthorized():
    async with AsyncClient(app=app, base_url="http://test") as ac:
        response = await ac.get("/api/v1/production/overview?line_id=LINE-A&time_range=24h")

        assert response.status_code == 401
```

#### 2.3.2 WebSocket集成测试

```python
# tests/test_websocket.py
import pytest
from websocket import create_connection

@pytest.mark.asyncio
async def test_websocket_notification():
    ws = create_connection("ws://localhost:8000/ws/notifications?token=test-token")
    ws.send("subscribe:line LINE-A")

    message = ws.recv()
    assert "subscribed" in message

    ws.close()
```

### 2.4 性能测试

#### 2.4.1 负载测试配置（使用locust）

```python
# locustfile.py
from locust import HttpUser, task, between

class APIUser(HttpUser):
    wait_times = between(1, 3)

    @task
    def get_overview(self):
        self.client.get("/api/v1/production/overview?line_id=LINE-A&time_range=24h", headers={"Authorization": "Bearer test-token"})

    @task
    def get_alerts(self):
        self.client.get("/api/v1/alerts/list?page=1&page_size=20", headers={"Authorization": "Bearer test-token"})
```

#### 2.4.2 前端性能测试（使用Lighthouse CI）

```javascript
// performance-test.js
const lighthouse = require('lighthouse');
const chromeLauncher = require('chrome-launcher');

async function runLighthouse(url) {
  const chrome = await chromeLauncher.launch({ chromeFlags: ['--headless'] });

  const options = {
    logLevel: 'info',
    output: 'json',
    onlyCategories: ['performance'],
    port: chrome.port
  };

  const runnerResult = await lighthouse(url, options);
  const score = runnerResult.lhr.categories.performance.score * 100;

  console.log(`Performance score: ${score}`);

  await chrome.kill();

  if (score < 90) {
    throw new Error(`Performance score ${score} is below threshold 90`);
  }
}

runLighthouse('http://localhost:3000/dashboard');
```

### 2.5 测试覆盖率要求

| 模块类型 | 覆盖率要求 | 说明 |
|---------|-----------|------|
| 核心业务逻辑 | ≥80% | Service层、关键算法 |
| API接口 | ≥70% | Router层 |
| 前端组件 | ≥60% | 可复用组件、关键页面 |
| 工具函数 | ≥90% | 纯函数、数据处理 |

---

## 第三章 接口规范与数据字典

### 3.1 RESTful API规范

#### 3.1.1 通用响应格式

```python
# 成功响应
{
  "code": 200,
  "message": "Success",
  "data": { ... },
  "timestamp": "2026-01-12T14:35:00Z",
  "traceId": "trace-abc123"
}

# 错误响应
{
  "code": 400,
  "message": "Invalid parameter",
  "error": {
    "field": "lineId",
    "reason": "Line ID is required"
  },
  "timestamp": "2026-01-12T14:35:00Z",
  "traceId": "trace-abc123"
}

# 分页响应
{
  "code": 200,
  "message": "Success",
  "data": {
    "items": [ ... ],
    "total": 150,
    "page": 1,
    "pageSize": 20,
    "totalPages": 8
  },
  "timestamp": "2026-01-12T14:35:00Z"
}
```